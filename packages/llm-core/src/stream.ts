import type { StreamCallbacks, StreamRequest } from "./types";

/**
 * Abstract base class for stream adapters.
 * 流适配器抽象基类。
 *
 * Defines the interface for connecting and disconnecting from a stream source.
 * 定义连接和断开流源的接口。
 */
export abstract class StreamAdapter {
  /**
   * Connect to the stream source.
   * 连接到流源。
   * @param request The stream request object / 流请求对象
   * @param callbacks Callbacks for stream events / 流事件回调
   */
  abstract connect(request: StreamRequest, callbacks: StreamCallbacks): void;

  /**
   * Disconnect from the stream source.
   * 断开流源连接。
   */
  abstract disconnect(): void;
}

/**
 * Mock implementation of StreamAdapter for testing and development.
 * 用于测试和开发的 StreamAdapter 模拟实现。
 */
export class MockStreamAdapter extends StreamAdapter {
  private aborted = false;

  connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.aborted = false;
    callbacks.onStart?.();
    const processMock = async () => {
      await new Promise((r) => setTimeout(r, 600));
      if (this.aborted) return;
      if (request.config.useThinking) {
        const thoughts = this.generateThoughts(request.messages[request.messages.length - 1].content);
        for (const token of thoughts) {
          if (this.aborted) return;
          await new Promise((r) => setTimeout(r, 15));
          callbacks.onThinking?.(token);
        }
        await new Promise((r) => setTimeout(r, 500));
      }
      const response = this.generateResponse(request.messages[request.messages.length - 1].content, request.modelId);
      for (const token of response) {
        if (this.aborted) return;
        await new Promise((r) => setTimeout(r, 10));
        callbacks.onContent?.(token);
      }
      callbacks.onEnd?.();
    };
    processMock().catch((e) => callbacks.onError?.(e));
  }

  disconnect() {
    this.aborted = true;
  }

  private generateThoughts(query: string): string {
    const q = query.toLowerCase();
    if (q.includes("react") || q.includes("code"))
      return `1. Analyze Request: User asks about code/React.\n2. Knowledge Retrieval: Fetching React 19 hooks patterns.\n3. Safety Check: Code is safe to generate.\n4. Drafting: Structuring the component with TypeScript.`;
    return `1. Intent Recognition: Analyzing "${query}".\n2. Context Search: Checking relevant knowledge bases.\n3. Reasoning: Formulating a comprehensive answer.\n4. Formatting: Ensuring markdown output.`;
  }

  private generateResponse(query: string, model: string): string {
    if (query.includes("code") || query.includes("react"))
      return `Here is a **React** example using the requested pattern.\n\n\`\`\`tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c+1)}>{count}</button>;\n}\n\`\`\`\n\nGenerated by ${model}.`;

    if (query.includes("@User Info") || query.includes("@用户信息")) {
      return `I found the user information you requested:\n\n:::user-profile{name="Alice Chen" role="Senior Frontend Engineer" email="alice.chen@example.com" location="Shanghai, China" avatar="https://api.dicebear.com/7.x/avataaars/svg?seed=Alice"}\n:::\n\nIs there anything else you need?`;
    }

    return `This is a simulated response for "${query}".\n\nI am running on the **${model}** architecture. The system just simulated a full streaming process including a "Thinking" phase (if enabled) followed by the content stream.`;
  }
}

/**
 * Server-Sent Events (SSE) implementation of StreamAdapter.
 * StreamAdapter 的服务器发送事件 (SSE) 实现。
 *
 * Uses HTTP POST to send the request and receives the response via SSE.
 * 使用 HTTP POST 发送请求，并通过 SSE 接收响应。
 */
export class SSEStreamAdapter extends StreamAdapter {
  private controller: AbortController | null = null;
  private endpoint: string;

  constructor(endpoint: string = "/api/chat/stream") {
    super();
    this.endpoint = endpoint;
  }

  async connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.controller = new AbortController();
    callbacks.onStart?.();

    try {
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(request),
        signal: this.controller.signal
      });

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      if (!response.body) throw new Error("Response body is null");

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed === "data: [DONE]") continue;

          if (trimmed.startsWith("data: ")) {
            try {
              const data = JSON.parse(trimmed.slice(6));
              if (data.thinking) callbacks.onThinking?.(data.thinking);
              if (data.content) callbacks.onContent?.(data.content);
              if (data.error) throw new Error(data.error);
            } catch (e) {
              console.warn("SSE Parse Error:", e);
            }
          }
        }
      }
      callbacks.onEnd?.();
    } catch (err: any) {
      if (err.name === "AbortError") return;
      callbacks.onError?.(err);
    }
  }

  disconnect() {
    this.controller?.abort();
  }
}

/**
 * WebSocket implementation of StreamAdapter.
 * StreamAdapter 的 WebSocket 实现。
 *
 * Uses a full-duplex WebSocket connection for streaming.
 * 使用全双工 WebSocket 连接进行流式传输。
 */
export class WebSocketStreamAdapter extends StreamAdapter {
  private ws: WebSocket | null = null;
  private url: string;

  constructor(url: string = "ws://localhost:3000/ws/chat") {
    super();
    this.url = url;
  }

  connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      this.ws?.send(JSON.stringify(request));
      callbacks.onStart?.();
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.thinking) callbacks.onThinking?.(data.thinking);
        if (data.content) callbacks.onContent?.(data.content);
        if (data.done) {
          callbacks.onEnd?.();
          this.ws?.close();
        }
      } catch (e) {
        callbacks.onError?.(new Error("WS Parse Error"));
      }
    };

    this.ws.onerror = (e) => callbacks.onError?.(new Error("WebSocket Error"));
    this.ws.onclose = () => {
      /* handle close */
    };
  }

  disconnect() {
    this.ws?.close();
  }
}

/**
 * Main client for handling stream operations.
 * 处理流操作的主客户端。
 *
 * Acts as a factory and facade for different stream adapters.
 * 充当不同流适配器的工厂和外观。
 */
export class StreamClient {
  private adapter: StreamAdapter;

  /**
   * @param protocolOrAdapter Protocol string ('mock', 'sse', 'websocket') or custom StreamAdapter instance / 协议字符串或自定义适配器实例
   * @param endpoint Optional endpoint URL for SSE or WebSocket / SSE 或 WebSocket 的可选端点 URL
   */
  constructor(protocolOrAdapter: "mock" | "sse" | "websocket" | StreamAdapter = "mock", endpoint?: string) {
    if (typeof protocolOrAdapter === "object") {
      this.adapter = protocolOrAdapter;
    } else {
      switch (protocolOrAdapter) {
        case "sse":
          this.adapter = new SSEStreamAdapter(endpoint);
          break;
        case "websocket":
          this.adapter = new WebSocketStreamAdapter(endpoint);
          break;
        default:
          this.adapter = new MockStreamAdapter();
      }
    }
  }

  stream(request: StreamRequest, callbacks: StreamCallbacks) {
    this.adapter.connect(request, callbacks);
  }

  abort() {
    this.adapter.disconnect();
  }
}
