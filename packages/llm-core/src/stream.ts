import type { StreamCallbacks, StreamRequest } from "./types";

export abstract class StreamAdapter {
  abstract connect(request: StreamRequest, callbacks: StreamCallbacks): void;
  abstract disconnect(): void;
}

export class MockStreamAdapter extends StreamAdapter {
  private aborted = false;

  connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.aborted = false;
    callbacks.onStart?.();
    const processMock = async () => {
      await new Promise((r) => setTimeout(r, 600));
      if (this.aborted) return;
      if (request.config.useThinking) {
        const thoughts = this.generateThoughts(request.messages[request.messages.length - 1].content);
        for (const token of thoughts) {
          if (this.aborted) return;
          await new Promise((r) => setTimeout(r, 15));
          callbacks.onThinking?.(token);
        }
        await new Promise((r) => setTimeout(r, 500));
      }
      const response = this.generateResponse(request.messages[request.messages.length - 1].content, request.modelId);
      for (const token of response) {
        if (this.aborted) return;
        await new Promise((r) => setTimeout(r, 10));
        callbacks.onContent?.(token);
      }
      callbacks.onEnd?.();
    };
    processMock().catch((e) => callbacks.onError?.(e));
  }

  disconnect() {
    this.aborted = true;
  }

  private generateThoughts(query: string): string {
    const q = query.toLowerCase();
    if (q.includes("react") || q.includes("code"))
      return `1. Analyze Request: User asks about code/React.\n2. Knowledge Retrieval: Fetching React 19 hooks patterns.\n3. Safety Check: Code is safe to generate.\n4. Drafting: Structuring the component with TypeScript.`;
    return `1. Intent Recognition: Analyzing "${query}".\n2. Context Search: Checking relevant knowledge bases.\n3. Reasoning: Formulating a comprehensive answer.\n4. Formatting: Ensuring markdown output.`;
  }

  private generateResponse(query: string, model: string): string {
    if (query.includes("code") || query.includes("react"))
      return `Here is a **React** example using the requested pattern.\n\n\`\`\`tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c+1)}>{count}</button>;\n}\n\`\`\`\n\nGenerated by ${model}.`;
    return `This is a simulated response for "${query}".\n\nI am running on the **${model}** architecture. The system just simulated a full streaming process including a "Thinking" phase (if enabled) followed by the content stream.`;
  }
}

export class SSEStreamAdapter extends StreamAdapter {
  private controller: AbortController | null = null;
  private endpoint: string;

  constructor(endpoint: string = "/api/chat/stream") {
    super();
    this.endpoint = endpoint;
  }

  async connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.controller = new AbortController();
    callbacks.onStart?.();

    try {
      const response = await fetch(this.endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(request),
        signal: this.controller.signal
      });

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      if (!response.body) throw new Error("Response body is null");

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";

        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed === "data: [DONE]") continue;

          if (trimmed.startsWith("data: ")) {
            try {
              const data = JSON.parse(trimmed.slice(6));
              if (data.thinking) callbacks.onThinking?.(data.thinking);
              if (data.content) callbacks.onContent?.(data.content);
              if (data.error) throw new Error(data.error);
            } catch (e) {
              console.warn("SSE Parse Error:", e);
            }
          }
        }
      }
      callbacks.onEnd?.();
    } catch (err: any) {
      if (err.name === "AbortError") return;
      callbacks.onError?.(err);
    }
  }

  disconnect() {
    this.controller?.abort();
  }
}

export class WebSocketStreamAdapter extends StreamAdapter {
  private ws: WebSocket | null = null;
  private url: string;

  constructor(url: string = "ws://localhost:3000/ws/chat") {
    super();
    this.url = url;
  }

  connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.ws = new WebSocket(this.url);

    this.ws.onopen = () => {
      this.ws?.send(JSON.stringify(request));
      callbacks.onStart?.();
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.thinking) callbacks.onThinking?.(data.thinking);
        if (data.content) callbacks.onContent?.(data.content);
        if (data.done) {
          callbacks.onEnd?.();
          this.ws?.close();
        }
      } catch (e) {
        callbacks.onError?.(new Error("WS Parse Error"));
      }
    };

    this.ws.onerror = (e) => callbacks.onError?.(new Error("WebSocket Error"));
    this.ws.onclose = () => {
      /* handle close */
    };
  }

  disconnect() {
    this.ws?.close();
  }
}

export class StreamClient {
  private adapter: StreamAdapter;

  constructor(protocolOrAdapter: "mock" | "sse" | "websocket" | StreamAdapter = "mock", endpoint?: string) {
    if (typeof protocolOrAdapter === "object") {
      this.adapter = protocolOrAdapter;
    } else {
      switch (protocolOrAdapter) {
        case "sse":
          this.adapter = new SSEStreamAdapter(endpoint);
          break;
        case "websocket":
          this.adapter = new WebSocketStreamAdapter(endpoint);
          break;
        default:
          this.adapter = new MockStreamAdapter();
      }
    }
  }

  stream(request: StreamRequest, callbacks: StreamCallbacks) {
    this.adapter.connect(request, callbacks);
  }

  abort() {
    this.adapter.disconnect();
  }
}
