import type { StreamCallbacks, StreamRequest } from './types';

export abstract class StreamAdapter {
  abstract connect(request: StreamRequest, callbacks: StreamCallbacks): void;
  abstract disconnect(): void;
}

export class MockStreamAdapter extends StreamAdapter {
  private aborted = false;

  connect(request: StreamRequest, callbacks: StreamCallbacks) {
    this.aborted = false;
    callbacks.onStart?.();
    const processMock = async () => {
      await new Promise(r => setTimeout(r, 600));
      if (this.aborted) return;
      if (request.config.useThinking) {
        const thoughts = this.generateThoughts(request.messages[request.messages.length - 1].content);
        for (const token of thoughts) {
          if (this.aborted) return;
          await new Promise(r => setTimeout(r, 15));
          callbacks.onThinking?.(token);
        }
        await new Promise(r => setTimeout(r, 500));
      }
      const response = this.generateResponse(request.messages[request.messages.length - 1].content, request.modelId);
      for (const token of response) {
        if (this.aborted) return;
        await new Promise(r => setTimeout(r, 10));
        callbacks.onContent?.(token);
      }
      callbacks.onEnd?.();
    };
    processMock().catch(e => callbacks.onError?.(e));
  }

  disconnect() { this.aborted = true; }

  private generateThoughts(query: string): string {
    const q = query.toLowerCase();
    if (q.includes('react') || q.includes('code')) return `1. Analyze Request: User asks about code/React.\n2. Knowledge Retrieval: Fetching React 19 hooks patterns.\n3. Safety Check: Code is safe to generate.\n4. Drafting: Structuring the component with TypeScript.`;
    return `1. Intent Recognition: Analyzing "${query}".\n2. Context Search: Checking relevant knowledge bases.\n3. Reasoning: Formulating a comprehensive answer.\n4. Formatting: Ensuring markdown output.`;
  }

  private generateResponse(query: string, model: string): string {
    if (query.includes('code') || query.includes('react')) return `Here is a **React** example using the requested pattern.\n\n\`\`\`tsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(c => c+1)}>{count}</button>;\n}\n\`\`\`\n\nGenerated by ${model}.`;
    return `This is a simulated response for "${query}".\n\nI am running on the **${model}** architecture. The system just simulated a full streaming process including a "Thinking" phase (if enabled) followed by the content stream.`;
  }
}

export class StreamClient {
  private adapter: StreamAdapter;
  constructor(protocol: 'mock' | 'sse' | 'websocket' = 'mock') {
    this.adapter = new MockStreamAdapter();
  }
  stream(request: StreamRequest, callbacks: StreamCallbacks) {
    this.adapter.connect(request, callbacks);
  }
  abort() {
    this.adapter.disconnect();
  }
}
